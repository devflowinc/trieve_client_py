{
  "openapi": "3.0.3",
  "info": {
    "title": "trieve-server",
    "description": "Trieve REST API OpenAPI Documentation",
    "license": {
      "name": ""
    },
    "version": "0.3.2"
  },
  "paths": {
    "/api/auth": {
      "get": {
        "tags": [
          "auth"
        ],
        "summary": "login",
        "description": "login\n\nThis will redirect you to the OAuth provider for authentication with email/pass, SSO, Google, Github, etc.",
        "operationId": "login",
        "requestBody": {
          "description": "Query parameters for login to be included as kv pairs after ? on the request URL.",
          "content": {
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/AuthQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "303": {
            "description": "Response that redirects to OAuth provider through a Location header to be handled by browser."
          },
          "400": {
            "description": "OAuth error likely with OIDC provider.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "auth"
        ],
        "summary": "logout",
        "description": "logout\n\nInvalidate your current auth credential stored typically stored in a cookie. This does not invalidate your API key.",
        "operationId": "logout",
        "responses": {
          "204": {
            "description": "Confirmation that your current auth token has been invalidated. This does not invalidate your API key."
          }
        }
      }
    },
    "/api/auth/callback": {
      "get": {
        "tags": [
          "auth"
        ],
        "summary": "openid_callback",
        "description": "openid_callback\n\nThis is the callback route for the OAuth provider, it should not be called directly. Redirects to browser with set-cookie header.",
        "operationId": "callback",
        "responses": {
          "200": {
            "description": "Response that returns with set-cookie header",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlimUser"
                }
              }
            }
          },
          "400": {
            "description": "Email or password empty or incorrect",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/auth/me": {
      "get": {
        "tags": [
          "auth"
        ],
        "summary": "get_me",
        "description": "get_me\n\nGet the user corresponding to your current auth credentials.",
        "operationId": "get_me",
        "responses": {
          "200": {
            "description": "The user corresponding to your current auth credentials",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlimUser"
                }
              }
            }
          },
          "400": {
            "description": "Error message indicitating you are not currently signed in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": []
          },
          {
            "Cookie": []
          }
        ]
      }
    },
    "/api/bookmark/{group_id}/{bookmark_id}": {
      "delete": {
        "tags": [
          "chunk_group"
        ],
        "summary": "delete_bookmark",
        "description": "delete_bookmark\n\nRoute to delete a bookmark. Think of a bookmark as a chunk which is a member of a group.",
        "operationId": "delete_bookmark",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "group_id",
            "in": "path",
            "description": "Id of the group to remove the bookmark'ed chunk from",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "bookmark_id",
            "in": "path",
            "description": "Id of the bookmark to remove",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the chunk was removed to the group"
          },
          "400": {
            "description": "Service error relating to removing the chunk from the group",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk": {
      "post": {
        "tags": [
          "chunk"
        ],
        "summary": "create_chunk",
        "description": "create_chunk\n\nCreate a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.",
        "operationId": "create_chunk",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create a new chunk (chunk)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateChunkData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "JSON response payload containing the created chunk",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReturnCreatedChunk"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to to creating a chunk, likely due to conflicting tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk/gen_suggestions": {
      "post": {
        "tags": [
          "chunk"
        ],
        "summary": "get_suggested_queries",
        "description": "get_suggested_queries\n\nThis endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.",
        "operationId": "create_suggested_queries_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get alternative suggested queries",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SuggestedQueriesRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A JSON object containing a list of alternative suggested queries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuggestedQueriesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to to updating chunk, likely due to conflicting tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk/generate": {
      "post": {
        "tags": [
          "chunk"
        ],
        "summary": "augmented_generation_from_chunks",
        "description": "augmented_generation_from_chunks\n\nThis endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \"search before generate\" page at docs.trieve.ai.",
        "operationId": "generate_off_chunks",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to perform RAG on some chunks (chunks)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateChunksRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "This will be a JSON response of a string containing the LLM's generated inference. Response if not streaming.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to to updating chunk, likely due to conflicting tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk/recommend": {
      "post": {
        "tags": [
          "chunk"
        ],
        "summary": "get_recommended_chunks",
        "description": "get_recommended_chunks\n\nGet recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \"add to playlist\" recommendation feature on Spotify. This request pairs especially well with our groups endpoint.",
        "operationId": "get_recommended_chunks",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get recommendations of chunks similar to the chunks in the request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecommendChunksRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "JSON response payload containing chunks with scores which are similar to those in the request body",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ChunkMetadataWithFileData"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to to getting similar chunks",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk/search": {
      "post": {
        "tags": [
          "chunk"
        ],
        "summary": "search",
        "description": "search\n\nThis route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results' `chunk_html` values will be modified with `<b>` tags for sub-sentence highlighting.",
        "operationId": "search_chunk",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to semantically search for chunks (chunks)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchChunkData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "chunks which are similar to the embedding vector of the search query",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchChunkQueryResponseBody"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to searching",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk/tracking_id/update": {
      "put": {
        "tags": [
          "chunk"
        ],
        "summary": "update_chunk_by_tracking_id",
        "description": "update_chunk_by_tracking_id\n\nUpdate a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.",
        "operationId": "update_chunk_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update a chunk by tracking_id (chunks)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateChunkByTrackingIdData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the chunk has been updated as per your request"
          },
          "400": {
            "description": "Service error relating to to updating chunk",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk/tracking_id/{tracking_id}": {
      "get": {
        "tags": [
          "chunk"
        ],
        "summary": "get_chunk_by_tracking_id",
        "description": "get_chunk_by_tracking_id\n\nGet a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.",
        "operationId": "get_chunk_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tracking_id",
            "in": "path",
            "description": "tracking_id of the chunk you want to fetch",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "chunk with the tracking_id that you were searching for",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChunkMetadata"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to fidning a chunk by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "chunk"
        ],
        "summary": "delete_chunk_by_tracking_id",
        "description": "delete_chunk_by_tracking_id\n\nDelete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.",
        "operationId": "delete_chunk_by_tracking_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tracking_id",
            "in": "path",
            "description": "tracking_id of the chunk you want to delete",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the chunk with the tracking_id specified was deleted"
          },
          "400": {
            "description": "Service error relating to finding a chunk by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk/update": {
      "put": {
        "tags": [
          "chunk"
        ],
        "summary": "update_chunk",
        "description": "update_chunk\n\nUpdate a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.",
        "operationId": "update_chunk",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update a chunk (chunk)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateChunkData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No content Ok response indicating the chunk was updated as requested"
          },
          "400": {
            "description": "Service error relating to to updating chunk, likely due to conflicting tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk/{chunk_id}": {
      "get": {
        "tags": [
          "chunk"
        ],
        "summary": "get_chunk",
        "description": "get_chunk\n\nGet a singular chunk by id.",
        "operationId": "get_chunk_by_id",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "chunk_id",
            "in": "path",
            "description": "Id of the chunk you want to fetch.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "chunk with the id that you were searching for",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChunkMetadata"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to fidning a chunk by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "chunk"
        ],
        "summary": "delete_chunk",
        "description": "delete_chunk\n\nDelete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.",
        "operationId": "delete_chunk",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "chunk_id",
            "in": "path",
            "description": "id of the chunk you want to delete",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the chunk with the id specified was deleted"
          },
          "400": {
            "description": "Service error relating to finding a chunk by tracking_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk_group": {
      "post": {
        "tags": [
          "chunk_group"
        ],
        "summary": "create_chunk_group",
        "description": "create_chunk_group\n\nCreate a new chunk_group. Think of this as analogous to a bookmark folder.",
        "operationId": "create_chunk_group",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to cretea a chunkGroup",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateChunkGroupData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created chunkGroup",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChunkGroup"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating the chunkGroup",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "chunk_group"
        ],
        "summary": "update_chunk_group",
        "description": "update_chunk_group\n\nUpdate a chunk_group. Think of this as analogous to a bookmark folder.",
        "operationId": "update_chunk_group",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update a chunkGroup",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateChunkGroupData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the chunkGroup was updated"
          },
          "400": {
            "description": "Service error relating to updating the chunkGroup",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/bookmark": {
      "post": {
        "tags": [
          "chunk_group"
        ],
        "operationId": "get_groups_chunk_is_in",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to get the groups that a chunk is in",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetGroupsForChunksData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "JSON body representing the groups that the chunk is in",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/BookmarkGroupResult"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the groups that the chunk is in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/search": {
      "post": {
        "tags": [
          "chunk_group"
        ],
        "summary": "group_search",
        "description": "group_search\n\nThis route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. Think about this like searching within a playlist or bookmark folder. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large.",
        "operationId": "search_groups",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to semantically search a group",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchGroupsData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Group chunks which are similar to the embedding vector of the search query",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchGroupsResult"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the groups that the chunk is in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/search_over_groups": {
      "post": {
        "tags": [
          "chunk_group"
        ],
        "summary": "group_oriented_search",
        "description": "group_oriented_search\n\nThis route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large. Compatible with semantic, fulltext, or hybrid search modes.",
        "operationId": "search_over_groups",
        "requestBody": {
          "description": "JSON request payload to semantically search over groups",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchChunkData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Group chunks which are similar to the embedding vector of the search query",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchOverGroupsResponseBody"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the groups that the chunk is in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/chunk_group/{group_id}": {
      "post": {
        "tags": [
          "chunk_group"
        ],
        "summary": "add_bookmark",
        "description": "add_bookmark\n\nRoute to add a bookmark. Think of a bookmark as a chunk which is a member of a group.",
        "operationId": "add_bookmark",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "group_id",
            "in": "path",
            "description": "Id of the group to add the chunk to as a bookmark",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to add a chunk to a group (bookmark it)",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddChunkToGroupData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the chunk was added to the group (bookmark'ed)."
          },
          "400": {
            "description": "Service error relating to getting the groups that the chunk is in.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "chunk_group"
        ],
        "summary": "delete_chunk_group",
        "description": "delete_chunk_group\n\nThis will delete a chunk_group. This will not delete the chunks that are in the group. We will soon support deleting a chunk_group along with its member chunks.",
        "operationId": "delete_chunk_group",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "group_id",
            "in": "path",
            "description": "Id of the chunk_group to delete",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the chunkGroup was deleted"
          },
          "400": {
            "description": "Service error relating to deleting the chunkGroup",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/chunk_group/{group_id}/{page}": {
      "get": {
        "tags": [
          "chunk_group"
        ],
        "summary": "get_all_bookmarks",
        "description": "get_all_bookmarks\n\nRoute to get all bookmarks for a group. Think of a bookmark as a chunk which is a member of a group. The response is paginated, with each page containing 10 chunks (bookmarks). Support for custom page size is coming soon.",
        "operationId": "get_all_bookmarks",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "group_id",
            "in": "path",
            "description": "The id of the group to get the chunks from",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "page",
            "in": "path",
            "description": "The page of chunks to get from the group",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64",
              "minimum": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Bookmark'ed chunks present within the specified group",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BookmarkData"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the groups that the chunk is in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/dataset": {
      "post": {
        "tags": [
          "dataset"
        ],
        "summary": "create_dataset",
        "description": "create_dataset\n\nCreate a new dataset. The auth'ed user must be an owner of the organization to create a dataset.",
        "operationId": "create_dataset",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create a new dataset",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateDatasetRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Dataset created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Dataset"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          },
          {
            "Cookie": [
              "owner"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "dataset"
        ],
        "summary": "update_dataset",
        "description": "update_dataset\n\nUpdate a dataset. The auth'ed user must be an owner of the organization to update a dataset.",
        "operationId": "update_dataset",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update a dataset",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateDatasetRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Dataset updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Dataset"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to updating the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          },
          {
            "Cookie": [
              "owner"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "dataset"
        ],
        "summary": "delete_dataset",
        "description": "delete_dataset\n\nDelete a dataset. The auth'ed user must be an owner of the organization to delete a dataset.",
        "operationId": "delete_dataset",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to delete a dataset",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteDatasetRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Dataset deleted successfully"
          },
          "400": {
            "description": "Service error relating to deleting the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          },
          {
            "Cookie": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/dataset/envs": {
      "get": {
        "tags": [
          "dataset"
        ],
        "summary": "get_client_dataset_config",
        "description": "get_client_dataset_config\n\nGet the client configuration for a dataset. Will use the TR-D",
        "operationId": "get_client_dataset_config",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Dataset environment variables",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClientDatasetConfiguration"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to retrieving the dataset. Typically this only happens when your auth credentials are invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/dataset/groups/{dataset_id}/{page}": {
      "get": {
        "tags": [
          "chunk_group"
        ],
        "summary": "get_dataset_groups",
        "description": "get_dataset_groups\n\nFetch the groups which belong to a dataset specified by its id.",
        "operationId": "get_specific_dataset_chunk_groups",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dataset_id",
            "in": "path",
            "description": "The id of the dataset to fetch groups for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "page",
            "in": "path",
            "description": "The page of groups to fetch. Each page contains 10 groups. Support for custom page size is coming soon.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "JSON body representing the groups created by the given dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GroupData"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the groups created by the given dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/dataset/organization/{organization_id}": {
      "get": {
        "tags": [
          "dataset"
        ],
        "summary": "get_organization_datasets",
        "description": "get_organization_datasets\n\nGet all datasets for an organization. The auth'ed user must be an admin or owner of the organization to get its datasets.",
        "operationId": "get_datasets_from_organization",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "id of the organization you want to retrieve datasets for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Datasets retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DatasetAndUsage"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to retrieving the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/dataset/{dataset_id}": {
      "get": {
        "tags": [
          "dataset"
        ],
        "summary": "get_dataset",
        "description": "get_dataset\n\nGet a dataset by id. The auth'ed user must be an admin or owner of the organization to get a dataset.",
        "operationId": "get_dataset",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dataset_id",
            "in": "path",
            "description": "The id of the dataset you want to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Dataset retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Dataset"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to retrieving the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/events/{page}": {
      "get": {
        "tags": [
          "events"
        ],
        "summary": "get_events",
        "description": "get_events\n\nGet events for the auth'ed user. Currently, this is only for events belonging to the auth'ed user. Soon, we plan to associate events to datasets instead of users. Each page contains 10 events.",
        "operationId": "get_events",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "path",
            "description": "Page number of events to get",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Events for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventReturn"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting events for the dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/file": {
      "post": {
        "tags": [
          "file"
        ],
        "summary": "upload_file",
        "description": "upload_file\n\nUpload a file to S3 attached to the server. The file will be converted to HTML with tika and chunked algorithmically, images will be OCR'ed with tesseract. The resulting chunks will be indexed and searchable. Optionally, you can only upload the file and manually create chunks associated to the file after. See docs.trieve.ai and/or contact us for more details and tips. Auth'ed user must be an admin or owner of the dataset's organization to upload a file.",
        "operationId": "upload_file_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to upload a file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UploadFileData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Confirmation that the file is uploading",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadFileResult"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to uploading the file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/file/{file_id}": {
      "get": {
        "tags": [
          "file"
        ],
        "summary": "get_file",
        "description": "get_file\n\nDownload a file from S3 attached to the server based on its id. We plan to add support for getting signed S3 URLs to download from S3 directly in a release soon.",
        "operationId": "get_file_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "file_id",
            "in": "path",
            "description": "The id of the file to fetch",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The signed s3 url corresponding to the file_id requested",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileDTO"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to finding the file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "file"
        ],
        "summary": "delete_file",
        "description": "delete_file\n\nDelete a file from S3 attached to the server based on its id. This will disassociate chunks from the file, but will not delete the chunks. We plan to add support for deleting chunks in a release soon. Auth'ed user must be an admin or owner of the dataset's organization to upload a file.",
        "operationId": "delete_file_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "file_id",
            "in": "path",
            "description": "The id of the file to delete",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "delete_chunks",
            "in": "query",
            "description": "Whether or not to delete the chunks associated with the file",
            "required": false,
            "schema": {
              "type": "boolean",
              "nullable": true
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation that the file has been deleted"
          },
          "400": {
            "description": "Service error relating to finding or deleting the file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/health": {
      "get": {
        "tags": [
          "health"
        ],
        "operationId": "health_check",
        "responses": {
          "200": {
            "description": "Confirmation that the service is healthy and can make embedding vectors"
          },
          "400": {
            "description": "Service error relating to making an embedding or overall service health",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/image/{file_name}": {
      "get": {
        "tags": [
          "file"
        ],
        "summary": "get_image_file",
        "description": "get_image_file\n\nWe strongly recommend not using this endpoint. It is disabled on the managed version and only meant for niche on-prem use cases where an image directory is mounted. Get in touch with us thru information on docs.trieve.ai for more information.",
        "operationId": "get_image_file",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "file_name",
            "in": "path",
            "description": "The name of the image file to return",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The raw image file corresponding to the file_name requested such that it can be a src for an img tag"
          },
          "400": {
            "description": "Service error relating to finding the file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/invitation": {
      "post": {
        "tags": [
          "invitation"
        ],
        "summary": "send_invitation",
        "description": "send_invitation\n\nInvitations act as a way to invite users to join an organization. After a user is invited, they will automatically be added to the organization with the role specified in the invitation once they set their.",
        "operationId": "post_invitation",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to send an invitation",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InvitationData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Ok response. Indicates that invitation email was sent correctly."
          },
          "400": {
            "description": "Invalid email or some other error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/message": {
      "post": {
        "tags": [
          "message"
        ],
        "summary": "create_message",
        "description": "create_message\n\nCreate a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.",
        "operationId": "create_message_completion_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create a message completion",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateMessageData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "This will be a JSON response of a string containing the LLM's generated inference. Response if not streaming.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting a chat completion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "message"
        ],
        "summary": "edit_message",
        "description": "edit_message\n\nEdit a message which exists within the topic's chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.",
        "operationId": "edit_message_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to edit a message and get a new stream",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EditMessageData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "This will be a HTTP stream, check the chat or search UI for an example how to process this"
          },
          "400": {
            "description": "Service error relating to getting a chat completion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "message"
        ],
        "summary": "regenerate_message",
        "description": "regenerate_message\n\nRegenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.",
        "operationId": "regenerate_message_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to delete an agent message then regenerate it in a strem",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegenerateMessageData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "This will be a JSON response of a string containing the LLM's generated inference. Response if not streaming.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting a chat completion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/messages/{messages_topic_id}": {
      "get": {
        "tags": [
          "message"
        ],
        "summary": "get_all_messages",
        "description": "get_all_messages\n\nGet all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.",
        "operationId": "get_all_topic_messages",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "messages_topic_id",
            "in": "path",
            "description": "The ID of the topic to get messages for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "All messages relating to the topic with the given ID",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Message"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the messages",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/organization": {
      "post": {
        "tags": [
          "organization"
        ],
        "summary": "create_organization",
        "description": "create_organization\n\nCreate a new organization. The auth'ed user who creates the organization will be the default owner of the organization.",
        "operationId": "create_organization",
        "requestBody": {
          "description": "The organization data that you want to create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrganizationData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Created organization object",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Organization"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating the organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "organization"
        ],
        "summary": "update_organization",
        "description": "update_organization\n\nUpdate an organization. Only the owner of the organization can update it.",
        "operationId": "update_organization",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The organization data that you want to update",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrganizationData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Updated organization object",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Organization"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to updating the organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "owner"
            ]
          },
          {
            "Cookie": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/organization/usage/{organization_id}": {
      "get": {
        "tags": [
          "organization"
        ],
        "summary": "get_organization_usage",
        "description": "get_organization_usage\n\nFetch the current usage specification of an organization by its id. The auth'ed user must be an admin or owner of the organization to fetch it.",
        "operationId": "get_organization_usage",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "The id of the organization you want to fetch the usage of.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The current usage of the specified organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationUsageCount"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to finding the organization's usage by id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/organization/users/{organization_id}": {
      "get": {
        "tags": [
          "organization"
        ],
        "summary": "get_organization_users",
        "description": "get_organization_users\n\nFetch the users of an organization by its id. The auth'ed user must be an admin or owner of the organization to fetch it.",
        "operationId": "get_organization_users",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "The id of the organization you want to fetch the users of.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Array of users who belong to the specified by organization",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SlimUser"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to finding the organization's users by id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/organization/{organization_id}": {
      "get": {
        "tags": [
          "organization"
        ],
        "summary": "get_organization",
        "description": "get_organization\n\nFetch the details of an organization by its id. The auth'ed user must be an admin or owner of the organization to fetch it.",
        "operationId": "get_organization_by_id",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "The id of the organization you want to fetch.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Organization with the id that was requested",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Organization"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to finding the organization by id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "admin"
            ]
          },
          {
            "Cookie": [
              "admin"
            ]
          }
        ]
      }
    },
    "/api/stripe/payment_link/{plan_id}/{organization_id}": {
      "get": {
        "tags": [
          "stripe"
        ],
        "operationId": "direct_to_payment_link",
        "parameters": [
          {
            "name": "plan_id",
            "in": "path",
            "description": "id of the plan you want to subscribe to",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "organization_id",
            "in": "path",
            "description": "id of the organization you want to subscribe to the plan",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "303": {
            "description": "SeeOther response redirecting user to stripe checkout page"
          },
          "400": {
            "description": "Service error relating to creating a URL for a stripe checkout page",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/stripe/plans": {
      "get": {
        "tags": [
          "stripe"
        ],
        "operationId": "get_all_plans",
        "responses": {
          "200": {
            "description": "List of all plans",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StripePlan"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting all plans",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        }
      }
    },
    "/api/stripe/subscription/{subscription_id}": {
      "delete": {
        "tags": [
          "stripe"
        ],
        "operationId": "cancel_subscription",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "subscription_id",
            "in": "path",
            "description": "id of the subscription you want to cancel",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Confirmation that the subscription was cancelled"
          },
          "400": {
            "description": "Service error relating to creating a URL for a stripe checkout page",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "api_key": [
              "owner"
            ]
          },
          {
            "cookie": [
              "owner"
            ]
          }
        ]
      }
    },
    "/api/stripe/subscription_plan/{subscription_id}/{plan_id}": {
      "patch": {
        "tags": [
          "stripe"
        ],
        "operationId": "update_subscription_plan",
        "parameters": [
          {
            "name": "TR-Organization",
            "in": "header",
            "description": "The organization id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "subscription_id",
            "in": "path",
            "description": "id of the subscription you want to update",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "plan_id",
            "in": "path",
            "description": "id of the plan you want to subscribe to",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Confirmation that the subscription was updated to the new plan"
          },
          "400": {
            "description": "Service error relating to updating the subscription to the new plan",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "api_key": [
              "readonly"
            ]
          },
          {
            "cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/topic": {
      "post": {
        "tags": [
          "topic"
        ],
        "summary": "create_topic",
        "description": "create_topic\n\nCreate a new chat topic. Topics are attached to a user and act as a coordinator for memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon.",
        "operationId": "create_topic",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to create chat topic",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTopicData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The JSON response payload containing the created topic",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Topic"
                }
              }
            }
          },
          "400": {
            "description": "Topic name empty or a service error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      },
      "put": {
        "tags": [
          "topic"
        ],
        "summary": "update_topic",
        "description": "update_topic\n\nUpdate an existing chat topic. Currently, only the name of the topic can be updated.",
        "operationId": "update_topic",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to update a chat topic",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTopicData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the topic was updated"
          },
          "400": {
            "description": "Service error relating to topic update",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      },
      "delete": {
        "tags": [
          "topic"
        ],
        "summary": "delete_topic",
        "description": "delete_topic\n\nDelete an existing chat topic. When a topic is deleted, all associated chat messages are also deleted.",
        "operationId": "delete_topic",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "JSON request payload to delete a chat topic",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteTopicData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Confirmation that the topic was deleted"
          },
          "400": {
            "description": "Service error relating to topic deletion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/topic/user/{user_id}": {
      "get": {
        "tags": [
          "topic"
        ],
        "summary": "get_all_topics_for_user",
        "description": "get_all_topics_for_user\n\nGet all topics belonging to a the auth'ed user. Soon, we plan to allow specification of the user for this route and include pagination.",
        "operationId": "get_all_topics_for_user",
        "parameters": [
          {
            "name": "user_id",
            "in": "path",
            "description": "The id of the user to get topics for",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "All topics belonging to a given user",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Topic"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to topic get",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/user": {
      "put": {
        "tags": [
          "user"
        ],
        "summary": "update_user",
        "description": "update_user\n\nUpdate a user's information. If the user_id is not provided, the auth'ed user will be updated. If the user_id is provided, the auth'ed user must be an admin (1) or owner (2) of the organization.",
        "operationId": "update_user",
        "requestBody": {
          "description": "JSON request payload to update user information for the auth'ed user",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateUserData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "JSON body representing the updated user information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlimUser"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to updating the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/user/delete_api_key": {
      "delete": {
        "tags": [
          "user"
        ],
        "summary": "delete_user_api_key",
        "description": "delete_user_api_key\n\nDelete an api key for the auth'ed user.",
        "operationId": "delete_user_api_key",
        "requestBody": {
          "description": "JSON request payload to delete a user api key",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteUserApiKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "JSON body representing the api_key for the user",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ApiKeyDTO"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating api_key for the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/user/files/{user_id}": {
      "get": {
        "tags": [
          "file"
        ],
        "summary": "get_user_files",
        "description": "get_user_files\n\nGet all files which belong to a given user specified by the user_id parameter.",
        "operationId": "get_user_files_handler",
        "parameters": [
          {
            "name": "TR-Dataset",
            "in": "header",
            "description": "The dataset id to use for the request",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "user_id",
            "in": "path",
            "description": "The id of the user to fetch files for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "JSON body representing the files uploaded by the given user",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/File"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to getting the files uploaded by the given user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    },
    "/api/user/set_api_key": {
      "post": {
        "tags": [
          "user"
        ],
        "summary": "set_user_api_key",
        "description": "set_user_api_key\n\nCreate a new api key for the auth'ed user. Successful response will contain the newly created api key. If a write role is assigned the api key will have permission level of the auth'ed user who calls this endpoint.",
        "operationId": "set_user_api_key",
        "requestBody": {
          "description": "JSON request payload to create a new user api key",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetUserApiKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "JSON body representing the api_key for the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetUserApiKeyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Service error relating to creating api_key for the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseBody"
                }
              }
            }
          }
        },
        "security": [
          {
            "ApiKey": [
              "readonly"
            ]
          },
          {
            "Cookie": [
              "readonly"
            ]
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "AddChunkToGroupData": {
        "type": "object",
        "required": [
          "chunk_id"
        ],
        "properties": {
          "chunk_id": {
            "type": "string",
            "format": "uuid",
            "description": "Id of the chunk to make a member of the group. Think of this as \"bookmark\"ing a chunk."
          }
        }
      },
      "ApiKeyDTO": {
        "type": "object",
        "required": [
          "id",
          "user_id",
          "name",
          "role",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "role": {
            "type": "integer",
            "format": "int32"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "user_id": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "AuthData": {
        "type": "object",
        "required": [
          "email",
          "password"
        ],
        "properties": {
          "email": {
            "type": "string"
          },
          "password": {
            "type": "string"
          }
        }
      },
      "AuthQuery": {
        "type": "object",
        "properties": {
          "inv_code": {
            "type": "string",
            "format": "uuid",
            "description": "Code sent via email as a result of successful call to send_invitation",
            "nullable": true
          },
          "organization_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of organization to authenticate into",
            "nullable": true
          },
          "redirect_uri": {
            "type": "string",
            "description": "URL to redirect to after successful login",
            "nullable": true
          }
        }
      },
      "BookmarkChunks": {
        "type": "object",
        "required": [
          "metadata"
        ],
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/ChunkMetadataWithFileData"
          }
        }
      },
      "BookmarkData": {
        "type": "object",
        "required": [
          "bookmarks",
          "group",
          "total_pages"
        ],
        "properties": {
          "bookmarks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BookmarkChunks"
            }
          },
          "group": {
            "$ref": "#/components/schemas/ChunkGroup"
          },
          "total_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "BookmarkGroupResult": {
        "type": "object",
        "required": [
          "chunk_uuid",
          "slim_groups"
        ],
        "properties": {
          "chunk_uuid": {
            "type": "string",
            "format": "uuid"
          },
          "slim_groups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SlimGroup"
            }
          }
        }
      },
      "ChatMessageProxy": {
        "type": "object",
        "required": [
          "role",
          "content"
        ],
        "properties": {
          "content": {
            "type": "string"
          },
          "role": {
            "type": "string"
          }
        }
      },
      "ChunkGroup": {
        "type": "object",
        "required": [
          "id",
          "name",
          "description",
          "created_at",
          "updated_at",
          "dataset_id"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "description": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "ChunkGroupAndFile": {
        "type": "object",
        "required": [
          "id",
          "dataset_id",
          "name",
          "description",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "description": {
            "type": "string"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "ChunkMetadata": {
        "type": "object",
        "required": [
          "id",
          "content",
          "created_at",
          "updated_at",
          "dataset_id",
          "weight"
        ],
        "properties": {
          "chunk_html": {
            "type": "string",
            "nullable": true
          },
          "content": {
            "type": "string"
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "qdrant_point_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "tag_set": {
            "type": "string",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "weight": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "ChunkMetadataWithFileData": {
        "type": "object",
        "required": [
          "id",
          "content",
          "qdrant_point_id",
          "created_at",
          "updated_at",
          "weight"
        ],
        "properties": {
          "chunk_html": {
            "type": "string",
            "nullable": true
          },
          "content": {
            "type": "string"
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "file_name": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "qdrant_point_id": {
            "type": "string",
            "format": "uuid"
          },
          "tag_set": {
            "type": "string",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "weight": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "ClientDatasetConfiguration": {
        "type": "object",
        "properties": {
          "CREATE_CHUNK_FEATURE": {
            "type": "boolean",
            "nullable": true
          },
          "DATE_RANGE_VALUE": {
            "type": "string",
            "nullable": true
          },
          "DOCUMENT_UPLOAD_FEATURE": {
            "type": "boolean",
            "nullable": true
          },
          "FILTER_ITEMS": {
            "nullable": true
          },
          "FRONTMATTER_VALS": {
            "type": "string",
            "nullable": true
          },
          "IMAGE_RANGE_END_KEY": {
            "type": "string",
            "nullable": true
          },
          "IMAGE_RANGE_START_KEY": {
            "type": "string",
            "nullable": true
          },
          "LINES_BEFORE_SHOW_MORE": {
            "type": "integer",
            "nullable": true,
            "minimum": 0
          },
          "SEARCH_QUERIES": {
            "type": "string",
            "nullable": true
          },
          "SUGGESTED_QUERIES": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "CreateChunkData": {
        "type": "object",
        "properties": {
          "chunk_html": {
            "type": "string",
            "description": "HTML content of the chunk. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content.",
            "nullable": true
          },
          "chunk_vector": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "float"
            },
            "description": "Chunk_vector is a vector of floats which can be used instead of generating a new embedding. This is useful for when you are using a pre-embedded dataset. If this is not provided, the innerText of the chunk_html will be used to create the embedding.",
            "nullable": true
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "File_uuid is the uuid of the file that the chunk is associated with. This is used to associate chunks with files. This is useful for when you want to delete a file and all of its associated chunks.",
            "nullable": true
          },
          "group_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Group ids are the ids of the groups that the chunk should be placed into. This is useful for when you want to create a chunk and add it to a group or multiple groups in one request. Necessary because this route queues the chunk for ingestion and the chunk may not exist yet immediatley after response.",
            "nullable": true
          },
          "link": {
            "type": "string",
            "description": "Link to the chunk. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation.",
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.",
            "nullable": true
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tag set is a list of tags. This can be used to filter chunks by tag. Unlike with metadata filtering, HNSW indices will exist for each tag such that there is not a performance hit for filtering on them.",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "description": "Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results.",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Tracking_id is a string which can be used to identify a chunk. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.",
            "nullable": true
          },
          "weight": {
            "type": "number",
            "format": "double",
            "description": "Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk's dataset dataset.",
            "nullable": true
          }
        }
      },
      "CreateChunkGroupData": {
        "type": "object",
        "required": [
          "name",
          "description"
        ],
        "properties": {
          "description": {
            "type": "string",
            "description": "Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for."
          },
          "name": {
            "type": "string",
            "description": "Name to assign to the chunk_group. Does not need to be unique."
          }
        }
      },
      "CreateDatasetRequest": {
        "type": "object",
        "required": [
          "dataset_name",
          "organization_id",
          "server_configuration",
          "client_configuration"
        ],
        "properties": {
          "client_configuration": {
            "description": "Client configuration for the dataset, can be arbitrary JSON. We recommend setting to `{}` to start. See docs.trieve.ai for more information or adjust with the admin dashboard."
          },
          "dataset_name": {
            "type": "string",
            "description": "Name of the dataset. Must be unique within the organization."
          },
          "organization_id": {
            "type": "string",
            "format": "uuid",
            "description": "Organization ID that the dataset will belong to."
          },
          "server_configuration": {
            "description": "Server configuration for the dataset, can be arbitrary JSON. We recommend setting to `{}` to start. See docs.trieve.ai for more information or adjust with the admin dashboard."
          }
        }
      },
      "CreateMessageData": {
        "type": "object",
        "required": [
          "new_message_content",
          "topic_id"
        ],
        "properties": {
          "highlight_citations": {
            "type": "boolean",
            "description": "Whether or not to highlight the citations in the response. If this is set to true or not included, the citations will be highlighted. If this is set to false, the citations will not be highlighted. Default is true.",
            "nullable": true
          },
          "highlight_delimiters": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The delimiters to use for highlighting the citations. If this is not included, the default delimiters will be used. Default is `[\".\", \"!\", \"?\", \"\\n\", \"\\t\", \",\"]`.",
            "nullable": true
          },
          "model": {
            "type": "string",
            "description": "The model to use for the assistant's messages. This can be any model from the openrouter model list. If no model is provided, the gryphe/mythomax-l2-13b will be used.",
            "nullable": true
          },
          "new_message_content": {
            "type": "string",
            "description": "The content of the user message to attach to the topic and then generate an assistant message in response to."
          },
          "stream_response": {
            "type": "boolean",
            "description": "Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.",
            "nullable": true
          },
          "topic_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the topic to attach the message to."
          }
        }
      },
      "CreateOrganizationData": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The arbitrary name which will be used to identify the organization. This name must be unique."
          }
        }
      },
      "CreateTopicData": {
        "type": "object",
        "properties": {
          "first_user_message": {
            "type": "string",
            "description": "The first message which will belong to the topic. The topic name is generated based on this message similar to how it works in the OpenAI chat UX if a name is not explicitly provided on the name request body key.",
            "nullable": true
          },
          "model": {
            "type": "string",
            "description": "The model to use for the assistant's messages. This can be any model from the openrouter model list. If no model is provided, the gryphe/mythomax-l2-13b will be used.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "The name of the topic. If this is not provided, the topic name is generated from the first_user_message.",
            "nullable": true
          }
        }
      },
      "Dataset": {
        "type": "object",
        "required": [
          "id",
          "name",
          "created_at",
          "updated_at",
          "organization_id",
          "server_configuration",
          "client_configuration"
        ],
        "properties": {
          "client_configuration": {},
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "server_configuration": {},
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "DatasetAndOrgWithSubAndPlan": {
        "type": "object",
        "required": [
          "dataset",
          "organization"
        ],
        "properties": {
          "dataset": {
            "$ref": "#/components/schemas/Dataset"
          },
          "organization": {
            "$ref": "#/components/schemas/OrganizationWithSubAndPlan"
          }
        }
      },
      "DatasetAndUsage": {
        "type": "object",
        "required": [
          "dataset",
          "dataset_usage"
        ],
        "properties": {
          "dataset": {
            "$ref": "#/components/schemas/DatasetDTO"
          },
          "dataset_usage": {
            "$ref": "#/components/schemas/DatasetUsageCount"
          }
        }
      },
      "DatasetDTO": {
        "type": "object",
        "required": [
          "id",
          "name",
          "created_at",
          "updated_at",
          "organization_id",
          "client_configuration"
        ],
        "properties": {
          "client_configuration": {},
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "DatasetGroupQuery": {
        "type": "object",
        "required": [
          "dataset_id",
          "page"
        ],
        "properties": {
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "DatasetUsageCount": {
        "type": "object",
        "required": [
          "id",
          "dataset_id",
          "chunk_count"
        ],
        "properties": {
          "chunk_count": {
            "type": "integer",
            "format": "int32"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "DeleteBookmarkPathData": {
        "type": "object",
        "required": [
          "group_id",
          "bookmark_id"
        ],
        "properties": {
          "bookmark_id": {
            "type": "string",
            "format": "uuid"
          },
          "group_id": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "DeleteDatasetRequest": {
        "type": "object",
        "required": [
          "dataset_id"
        ],
        "properties": {
          "dataset_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the dataset you want to delete."
          }
        }
      },
      "DeleteGroupData": {
        "type": "object",
        "properties": {
          "delete_chunks": {
            "type": "boolean",
            "nullable": true
          }
        }
      },
      "DeleteTopicData": {
        "type": "object",
        "required": [
          "topic_id"
        ],
        "properties": {
          "topic_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the topic to target."
          }
        }
      },
      "DeleteUserApiKeyRequest": {
        "type": "object",
        "required": [
          "api_key_id"
        ],
        "properties": {
          "api_key_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the api key to delete."
          }
        }
      },
      "EditMessageData": {
        "type": "object",
        "required": [
          "topic_id",
          "message_sort_order",
          "new_message_content"
        ],
        "properties": {
          "highlight_citations": {
            "type": "boolean",
            "description": "Whether or not to highlight the citations in the response. If this is set to true or not included, the citations will be highlighted. If this is set to false, the citations will not be highlighted. Default is true.",
            "nullable": true
          },
          "highlight_delimiters": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The delimiters to use for highlighting the citations. If this is not included, the default delimiters will be used. Default is `[\".\", \"!\", \"?\", \"\\n\", \"\\t\", \",\"]`.",
            "nullable": true
          },
          "message_sort_order": {
            "type": "integer",
            "format": "int32",
            "description": "The sort order of the message to edit."
          },
          "model": {
            "type": "string",
            "description": "The model to use for the assistant generative inferences. This can be any model from the openrouter model list. If no model is provided, the gryphe/mythomax-l2-13b will be used.~",
            "nullable": true
          },
          "new_message_content": {
            "type": "string",
            "description": "The new content of the message to replace the old content with."
          },
          "stream_response": {
            "type": "boolean",
            "description": "Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.",
            "nullable": true
          },
          "topic_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the topic to edit the message at the given sort order for."
          }
        }
      },
      "ErrorResponseBody": {
        "type": "object",
        "required": [
          "message"
        ],
        "properties": {
          "message": {
            "type": "string"
          }
        }
      },
      "Event": {
        "type": "object",
        "required": [
          "id",
          "created_at",
          "updated_at",
          "dataset_id",
          "event_type",
          "event_data"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "event_data": {},
          "event_type": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "EventId": {
        "type": "object",
        "required": [
          "notification_id"
        ],
        "properties": {
          "notification_id": {
            "type": "string",
            "format": "uuid",
            "description": "Id of the notification to target."
          }
        }
      },
      "EventReturn": {
        "type": "object",
        "required": [
          "event",
          "full_count",
          "total_pages"
        ],
        "properties": {
          "event": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Events"
            }
          },
          "full_count": {
            "type": "integer",
            "format": "int32"
          },
          "total_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "Events": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/Event"
          }
        ]
      },
      "File": {
        "type": "object",
        "required": [
          "id",
          "user_id",
          "file_name",
          "created_at",
          "updated_at",
          "size",
          "dataset_id"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "file_name": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "size": {
            "type": "integer",
            "format": "int64"
          },
          "tag_set": {
            "type": "string",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "user_id": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "FileDTO": {
        "type": "object",
        "required": [
          "id",
          "user_id",
          "file_name",
          "created_at",
          "updated_at",
          "size",
          "s3_url"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "file_name": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "metadata": {
            "nullable": true
          },
          "s3_url": {
            "type": "string"
          },
          "size": {
            "type": "integer",
            "format": "int64"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "user_id": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "GenerateChunksRequest": {
        "type": "object",
        "required": [
          "prev_messages",
          "chunk_ids"
        ],
        "properties": {
          "chunk_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "The ids of the chunks to be retrieved and injected into the context window for RAG."
          },
          "model": {
            "type": "string",
            "description": "The model to use for the chat. This can be any model from the openrouter model list. If no model is provided, gryphe/mythomax-l2-13b will be used.",
            "nullable": true
          },
          "prev_messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChatMessageProxy"
            },
            "description": "The previous messages to be placed into the chat history. The last message in this array will be the prompt for the model to inference on. The length of this array must be at least 1."
          },
          "prompt": {
            "type": "string",
            "description": "Prompt for the last message in the prev_messages array. This will be used to generate the next message in the chat. The default is 'Respond to the instruction and include the doc numbers that you used in square brackets at the end of the sentences that you used the docs for:'. You can also specify an empty string to leave the final message alone such that your user's final message can be used as the prompt. See docs.trieve.ai or contact us for more information.",
            "nullable": true
          },
          "stream_response": {
            "type": "boolean",
            "description": "Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.",
            "nullable": true
          }
        }
      },
      "GenerateOffGroupData": {
        "type": "object",
        "required": [
          "group_id"
        ],
        "properties": {
          "group_id": {
            "type": "string",
            "format": "uuid"
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "nullable": true,
            "minimum": 0
          },
          "query": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "GetAllBookmarksData": {
        "type": "object",
        "required": [
          "group_id"
        ],
        "properties": {
          "group_id": {
            "type": "string",
            "format": "uuid"
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "nullable": true,
            "minimum": 0
          }
        }
      },
      "GetDirectPaymentLinkData": {
        "type": "object",
        "required": [
          "plan_id",
          "organization_id"
        ],
        "properties": {
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "plan_id": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "GetGroupsForChunksData": {
        "type": "object",
        "required": [
          "chunk_ids"
        ],
        "properties": {
          "chunk_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            }
          }
        }
      },
      "GetUserWithChunksData": {
        "type": "object",
        "required": [
          "user_id",
          "page"
        ],
        "properties": {
          "page": {
            "type": "integer",
            "format": "int64",
            "description": "The page of chunks to fetch. Each page is 10 chunks. Support for custom page size is coming soon."
          },
          "user_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the user to fetch the chunks for."
          }
        }
      },
      "GroupData": {
        "type": "object",
        "required": [
          "groups",
          "total_pages"
        ],
        "properties": {
          "groups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkGroupAndFile"
            }
          },
          "total_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "GroupScoreChunkDTO": {
        "type": "object",
        "required": [
          "group_id",
          "metadata"
        ],
        "properties": {
          "group_id": {
            "type": "string",
            "format": "uuid"
          },
          "metadata": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScoreChunkDTO"
            }
          }
        }
      },
      "InvitationData": {
        "type": "object",
        "required": [
          "organization_id",
          "user_role",
          "email",
          "app_url",
          "redirect_uri"
        ],
        "properties": {
          "app_url": {
            "type": "string",
            "description": "The url of the app that the user will be directed to in order to set their password. Usually admin.trieve.ai, but may differ for local dev or self-hosted setups."
          },
          "email": {
            "type": "string",
            "description": "The email of the user to invite. Must be a valid email as they will be sent an email to register."
          },
          "organization_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the organization to invite the user to."
          },
          "redirect_uri": {
            "type": "string",
            "description": "The url that the user will be redirected to after setting their password."
          },
          "user_role": {
            "type": "integer",
            "format": "int32",
            "description": "The role the user will have in the organization. 0 = User, 1 = Admin, 2 = Owner."
          }
        }
      },
      "Message": {
        "type": "object",
        "required": [
          "id",
          "topic_id",
          "sort_order",
          "content",
          "role",
          "deleted",
          "created_at",
          "updated_at",
          "dataset_id"
        ],
        "properties": {
          "completion_tokens": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "content": {
            "type": "string"
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "deleted": {
            "type": "boolean"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "prompt_tokens": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "role": {
            "type": "string"
          },
          "sort_order": {
            "type": "integer",
            "format": "int32"
          },
          "topic_id": {
            "type": "string",
            "format": "uuid"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "Organization": {
        "type": "object",
        "required": [
          "id",
          "name",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "registerable": {
            "type": "boolean",
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "OrganizationUsageCount": {
        "type": "object",
        "required": [
          "id",
          "org_id",
          "dataset_count",
          "user_count",
          "file_storage",
          "message_count"
        ],
        "properties": {
          "dataset_count": {
            "type": "integer",
            "format": "int32"
          },
          "file_storage": {
            "type": "integer",
            "format": "int64"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "message_count": {
            "type": "integer",
            "format": "int32"
          },
          "org_id": {
            "type": "string",
            "format": "uuid"
          },
          "user_count": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "OrganizationWithSubAndPlan": {
        "type": "object",
        "required": [
          "id",
          "name",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "plan": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StripePlan"
              }
            ],
            "nullable": true
          },
          "registerable": {
            "type": "boolean",
            "nullable": true
          },
          "subscription": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StripeSubscription"
              }
            ],
            "nullable": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "RecommendChunksRequest": {
        "type": "object",
        "required": [
          "positive_chunk_ids"
        ],
        "properties": {
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The number of chunks to return. This is the number of chunks which will be returned in the response. The default is 10.",
            "nullable": true,
            "minimum": 0
          },
          "positive_chunk_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "The ids of the chunks to be used as positive examples for the recommendation. The chunks in this array will be used to find similar chunks."
          }
        }
      },
      "RegenerateMessageData": {
        "type": "object",
        "required": [
          "topic_id"
        ],
        "properties": {
          "highlight_citations": {
            "type": "boolean",
            "description": "Whether or not to highlight the citations in the response. If this is set to true or not included, the citations will be highlighted. If this is set to false, the citations will not be highlighted. Default is true.",
            "nullable": true
          },
          "highlight_delimiters": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The delimiters to use for highlighting the citations. If this is not included, the default delimiters will be used. Default is `[\".\", \"!\", \"?\", \"\\n\", \"\\t\", \",\"]`.",
            "nullable": true
          },
          "model": {
            "type": "string",
            "description": "The model to use for the assistant generative inferences. This can be any model from the openrouter model list. If no model is provided, the gryphe/mythomax-l2-13b will be used.~",
            "nullable": true
          },
          "stream_response": {
            "type": "boolean",
            "description": "Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.",
            "nullable": true
          },
          "topic_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the topic to regenerate the last message for."
          }
        }
      },
      "ReturnCreatedChunk": {
        "type": "object",
        "required": [
          "chunk_metadata",
          "pos_in_queue"
        ],
        "properties": {
          "chunk_metadata": {
            "$ref": "#/components/schemas/ChunkMetadata"
          },
          "pos_in_queue": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "ScoreChunkDTO": {
        "type": "object",
        "required": [
          "metadata",
          "score"
        ],
        "properties": {
          "metadata": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkMetadataWithFileData"
            }
          },
          "score": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "SearchChunkData": {
        "type": "object",
        "required": [
          "search_type",
          "query"
        ],
        "properties": {
          "date_bias": {
            "type": "boolean",
            "description": "Set date_bias to true to bias search results towards more recent chunks. This will work best in hybrid search mode.",
            "nullable": true
          },
          "filters": {
            "description": "Filters is a JSON object which can be used to filter chunks. The values on each key in the object will be used to check for an exact substring match on the metadata values for each existing chunk. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.",
            "nullable": true
          },
          "get_collisions": {
            "type": "boolean",
            "description": "Set get_collisions to true to get the collisions for each chunk. This will only apply if environment variable COLLISIONS_ENABLED is set to true.",
            "nullable": true
          },
          "highlight_delimiters": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Set highlight_delimiters to a list of strings to use as delimiters for highlighting.",
            "nullable": true
          },
          "highlight_results": {
            "type": "boolean",
            "description": "Set highlight_results to true to highlight the results.",
            "nullable": true
          },
          "link": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Link set is a list of links. This can be used to filter chunks by link. HNSW indices do not exist for links, so there is a performance hit for filtering on them.",
            "nullable": true
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "description": "Page of chunks to fetch. Each page is 10 chunks. Support for custom page size is coming soon.",
            "nullable": true,
            "minimum": 0
          },
          "query": {
            "type": "string",
            "description": "Query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set."
          },
          "search_type": {
            "type": "string",
            "description": "Can be either \"semantic\", \"fulltext\", or \"hybrid\". \"hybrid\" will pull in one page (10 chunks) of both semantic and full-text results then re-rank them using BAAI/bge-reranker-large. \"semantic\" will pull in one page (10 chunks) of the nearest cosine distant vectors. \"fulltext\" will pull in one page (10 chunks) of full-text results based on SPLADE."
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tag_set is a list of tags. This can be used to filter chunks by tag. Unlike with metadata filtering, HNSW indices will exist for each tag such that there is not a performance hit for filtering on them.",
            "nullable": true
          },
          "time_range": {
            "type": "array",
            "items": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string"
                }
              ]
            },
            "description": "Time_range is a tuple of two ISO 8601 combined date and time without timezone. The first value is the start of the time range and the second value is the end of the time range. This can be used to filter chunks by time range. HNSW indices do not exist for time range, so there is a performance hit for filtering on them.",
            "nullable": true
          }
        }
      },
      "SearchChunkQueryResponseBody": {
        "type": "object",
        "required": [
          "score_chunks",
          "total_chunk_pages"
        ],
        "properties": {
          "score_chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScoreChunkDTO"
            }
          },
          "total_chunk_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SearchGroupsData": {
        "type": "object",
        "required": [
          "query",
          "group_id",
          "search_type"
        ],
        "properties": {
          "date_bias": {
            "type": "boolean",
            "description": "Set date_bias to true to bias search results towards more recent chunks. This will work best in hybrid search mode.",
            "nullable": true
          },
          "filters": {
            "description": "Filters is a JSON object which can be used to filter chunks. The values on each key in the object will be used to check for an exact substring match on the metadata values for each existing chunk. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.",
            "nullable": true
          },
          "group_id": {
            "type": "string",
            "format": "uuid",
            "description": "Group specifies the group to search within. Results will only consist of chunks which are bookmarks within the specified group."
          },
          "highlight_delimiters": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Set highlight_delimiters to a list of strings to use as delimiters for highlighting.",
            "nullable": true
          },
          "highlight_results": {
            "type": "boolean",
            "description": "Set highlight_results to true to highlight the results.",
            "nullable": true
          },
          "link": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The link set is a list of links. This can be used to filter chunks by link. HNSW indices do not exist for links, so there is a performance hit for filtering on them.",
            "nullable": true
          },
          "page": {
            "type": "integer",
            "format": "int64",
            "description": "The page of chunks to fetch. Each page is 10 chunks. Support for custom page size is coming soon.",
            "nullable": true,
            "minimum": 0
          },
          "query": {
            "type": "string",
            "description": "The query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set."
          },
          "search_type": {
            "type": "string",
            "description": "Search_type can be either \"semantic\", \"fulltext\", or \"hybrid\". \"hybrid\" will pull in one page (10 chunks) of both semantic and full-text results then re-rank them using BAAI/bge-reranker-large. \"semantic\" will pull in one page (10 chunks) of the nearest cosine distant vectors. \"fulltext\" will pull in one page (10 chunks) of full-text results based on SPLADE."
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The tag set is a list of tags. This can be used to filter chunks by tag. Unlike with metadata filtering, HNSW indices will exist for each tag such that there is not a performance hit for filtering on them.",
            "nullable": true
          }
        }
      },
      "SearchGroupsResult": {
        "type": "object",
        "required": [
          "bookmarks",
          "group",
          "total_pages"
        ],
        "properties": {
          "bookmarks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScoreChunkDTO"
            }
          },
          "group": {
            "$ref": "#/components/schemas/ChunkGroup"
          },
          "total_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SearchOverGroupsResponseBody": {
        "type": "object",
        "required": [
          "group_chunks",
          "total_chunk_pages"
        ],
        "properties": {
          "group_chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GroupScoreChunkDTO"
            }
          },
          "total_chunk_pages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SetUserApiKeyRequest": {
        "type": "object",
        "required": [
          "name",
          "role"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name which will be assigned to the new api key."
          },
          "role": {
            "type": "integer",
            "format": "int32",
            "description": "The role which will be assigned to the new api key. Either 0 (read), 1 (read and write at the level of the currently auth'ed user). The auth'ed user must have a role greater than or equal to the role being assigned which means they must be an admin (1) or owner (2) of the organization to assign write permissions with a role of 1."
          }
        }
      },
      "SetUserApiKeyResponse": {
        "type": "object",
        "required": [
          "api_key"
        ],
        "properties": {
          "api_key": {
            "type": "string",
            "description": "The api key which was created. This is the value which should be used in the Authorization header."
          }
        }
      },
      "SlimGroup": {
        "type": "object",
        "required": [
          "id",
          "name",
          "dataset_id",
          "of_current_dataset"
        ],
        "properties": {
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "of_current_dataset": {
            "type": "boolean"
          }
        }
      },
      "SlimUser": {
        "type": "object",
        "required": [
          "id",
          "email",
          "visible_email",
          "user_orgs",
          "orgs"
        ],
        "properties": {
          "email": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "orgs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Organization"
            }
          },
          "user_orgs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UserOrganization"
            }
          },
          "username": {
            "type": "string",
            "nullable": true
          },
          "visible_email": {
            "type": "boolean"
          },
          "website": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "StripePlan": {
        "type": "object",
        "required": [
          "id",
          "stripe_id",
          "chunk_count",
          "file_storage",
          "user_count",
          "dataset_count",
          "message_count",
          "amount",
          "created_at",
          "updated_at",
          "name"
        ],
        "properties": {
          "amount": {
            "type": "integer",
            "format": "int64"
          },
          "chunk_count": {
            "type": "integer",
            "format": "int32"
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_count": {
            "type": "integer",
            "format": "int32"
          },
          "file_storage": {
            "type": "integer",
            "format": "int64"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "message_count": {
            "type": "integer",
            "format": "int32"
          },
          "name": {
            "type": "string"
          },
          "stripe_id": {
            "type": "string"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "user_count": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "StripeSubscription": {
        "type": "object",
        "required": [
          "id",
          "stripe_id",
          "plan_id",
          "organization_id",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "current_period_end": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "plan_id": {
            "type": "string",
            "format": "uuid"
          },
          "stripe_id": {
            "type": "string"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "SuggestedQueriesRequest": {
        "type": "object",
        "required": [
          "query"
        ],
        "properties": {
          "query": {
            "type": "string",
            "description": "The query to base the generated suggested queries off of."
          }
        }
      },
      "SuggestedQueriesResponse": {
        "type": "object",
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Topic": {
        "type": "object",
        "required": [
          "id",
          "user_id",
          "name",
          "deleted",
          "created_at",
          "updated_at",
          "dataset_id"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "deleted": {
            "type": "boolean"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "user_id": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "UpdateChunkByTrackingIdData": {
        "type": "object",
        "required": [
          "tracking_id"
        ],
        "properties": {
          "chunk_html": {
            "type": "string",
            "description": "HTML content of the chunk you want to update. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content. If no chunk_html is provided, the existing chunk_html will be used.",
            "nullable": true
          },
          "link": {
            "type": "string",
            "description": "Link of the chunk you want to update. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation. If no link is provided, the existing link will be used.",
            "nullable": true
          },
          "metadata": {
            "description": "The metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. If no metadata is provided, the existing metadata will be used.",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "description": "Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results. If no time_stamp is provided, the existing time_stamp will be used.",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Tracking_id of the chunk you want to update. This is required to match an existing chunk."
          },
          "weight": {
            "type": "number",
            "format": "double",
            "description": "Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk's dataset dataset. If no weight is provided, the existing weight will be used.",
            "nullable": true
          }
        }
      },
      "UpdateChunkData": {
        "type": "object",
        "required": [
          "chunk_uuid"
        ],
        "properties": {
          "chunk_html": {
            "type": "string",
            "description": "HTML content of the chunk you want to update. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content. If no chunk_html is provided, the existing chunk_html will be used.",
            "nullable": true
          },
          "chunk_uuid": {
            "type": "string",
            "format": "uuid",
            "description": "Id of the chunk you want to update."
          },
          "link": {
            "type": "string",
            "description": "Link of the chunk you want to update. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation. If no link is provided, the existing link will be used.",
            "nullable": true
          },
          "metadata": {
            "description": "The metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. If no metadata is provided, the existing metadata will be used.",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "description": "Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results. If no time_stamp is provided, the existing time_stamp will be used.",
            "nullable": true
          },
          "tracking_id": {
            "type": "string",
            "description": "Tracking_id is a string which can be used to identify a chunk. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If no tracking_id is provided, the existing tracking_id will be used.",
            "nullable": true
          },
          "weight": {
            "type": "number",
            "format": "double",
            "description": "Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk's dataset dataset. If no weight is provided, the existing weight will be used.",
            "nullable": true
          }
        }
      },
      "UpdateChunkGroupData": {
        "type": "object",
        "required": [
          "group_id"
        ],
        "properties": {
          "description": {
            "type": "string",
            "description": "Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for. If not provided, the description will not be updated.",
            "nullable": true
          },
          "group_id": {
            "type": "string",
            "format": "uuid",
            "description": "Id of the chunk_group to update."
          },
          "name": {
            "type": "string",
            "description": "Name to assign to the chunk_group. Does not need to be unique. If not provided, the name will not be updated.",
            "nullable": true
          }
        }
      },
      "UpdateDatasetRequest": {
        "type": "object",
        "required": [
          "dataset_id"
        ],
        "properties": {
          "client_configuration": {
            "description": "The new client configuration of the dataset, can be arbitrary JSON. See docs.trieve.ai for more information. If not provided, the client configuration will not be updated.",
            "nullable": true
          },
          "dataset_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the dataset you want to update."
          },
          "dataset_name": {
            "type": "string",
            "description": "The new name of the dataset. Must be unique within the organization. If not provided, the name will not be updated.",
            "nullable": true
          },
          "server_configuration": {
            "description": "The new server configuration of the dataset, can be arbitrary JSON. See docs.trieve.ai for more information. If not provided, the server configuration will not be updated.",
            "nullable": true
          }
        }
      },
      "UpdateOrganizationData": {
        "type": "object",
        "required": [
          "organization_id"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The new name of the organization. If not provided, the name will not be updated.",
            "nullable": true
          },
          "organization_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the organization to update."
          }
        }
      },
      "UpdateSubscriptionData": {
        "type": "object",
        "required": [
          "subscription_id",
          "plan_id"
        ],
        "properties": {
          "plan_id": {
            "type": "string",
            "format": "uuid"
          },
          "subscription_id": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "UpdateTopicData": {
        "type": "object",
        "required": [
          "topic_id",
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The new name of the topic. A name is not generated from this field, it is used as-is."
          },
          "topic_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the topic to target."
          }
        }
      },
      "UpdateUserData": {
        "type": "object",
        "required": [
          "organization_id"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "In the sense of a legal name, not a username. The new name to assign to the user, if not provided, the current name will be used.",
            "nullable": true
          },
          "organization_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the organization to update the user for."
          },
          "role": {
            "type": "integer",
            "format": "int32",
            "description": "Either 0 (user), 1 (admin), or 2 (owner). If not provided, the current role will be used. The auth'ed user must have a role greater than or equal to the role being assigned.",
            "nullable": true
          },
          "user_id": {
            "type": "string",
            "format": "uuid",
            "description": "The id of the user to update, if not provided, the auth'ed user will be updated. If provided, the auth'ed user must be an admin (1) or owner (2) of the organization.",
            "nullable": true
          },
          "username": {
            "type": "string",
            "description": "The new username to assign to the user, if not provided, the current username will be used.",
            "nullable": true
          },
          "visible_email": {
            "type": "boolean",
            "description": "Determines if the user's email is visible to other users, if not provided, the current value will be used.",
            "nullable": true
          },
          "website": {
            "type": "string",
            "description": "The new website to assign to the user, if not provided, the current website will be used. Used for linking to the user's personal or company website.",
            "nullable": true
          }
        }
      },
      "UploadFileData": {
        "type": "object",
        "required": [
          "base64_file",
          "file_name",
          "file_mime_type"
        ],
        "properties": {
          "base64_file": {
            "type": "string",
            "description": "Base64 encoded file. Convert + to -, / to _, and remove the ending = if present. This is the standard base64url encoding."
          },
          "create_chunks": {
            "type": "boolean",
            "description": "Create chunks is a boolean which determines whether or not to create chunks from the file. If false, you can manually chunk the file and send the chunks to the create_chunk endpoint with the file_id to associate chunks with the file. Meant mostly for advanced users.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "Description is an optional convience field so you do not have to remember what the file contains or is about. It will be included on the group resulting from the file which will hold its chunk.",
            "nullable": true
          },
          "file_mime_type": {
            "type": "string",
            "description": "MIME type of the file being uploaded."
          },
          "file_name": {
            "type": "string",
            "description": "Name of the file being uploaded, including the extension."
          },
          "link": {
            "type": "string",
            "description": "Link to the file. This can also be any string. This can be used to filter when searching for the file's resulting chunks. The link value will not affect embedding creation.",
            "nullable": true
          },
          "metadata": {
            "description": "Metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. Will be passed down to the file's chunks.",
            "nullable": true
          },
          "tag_set": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tag set is a comma separated list of tags which will be passed down to the chunks made from the file. Tags are used to filter chunks when searching. HNSW indices are created for each tag such that there is no performance loss when filtering on them.",
            "nullable": true
          },
          "time_stamp": {
            "type": "string",
            "description": "Time stamp should be an ISO 8601 combined date and time without timezone. Time_stamp is used for time window filtering and recency-biasing search results. Will be passed down to the file's chunks.",
            "nullable": true
          }
        }
      },
      "UploadFileResult": {
        "type": "object",
        "required": [
          "file_metadata"
        ],
        "properties": {
          "file_metadata": {
            "$ref": "#/components/schemas/File"
          }
        }
      },
      "UserDTO": {
        "type": "object",
        "required": [
          "id",
          "visible_email",
          "created_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "email": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "username": {
            "type": "string",
            "nullable": true
          },
          "visible_email": {
            "type": "boolean"
          },
          "website": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "UserDTOWithChunks": {
        "type": "object",
        "required": [
          "id",
          "visible_email",
          "created_at",
          "total_chunks_created",
          "chunks"
        ],
        "properties": {
          "chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChunkMetadataWithFileData"
            }
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "email": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "total_chunks_created": {
            "type": "integer",
            "format": "int64"
          },
          "username": {
            "type": "string",
            "nullable": true
          },
          "visible_email": {
            "type": "boolean"
          },
          "website": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "UserOrganization": {
        "type": "object",
        "required": [
          "id",
          "user_id",
          "organization_id",
          "role",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "organization_id": {
            "type": "string",
            "format": "uuid"
          },
          "role": {
            "type": "integer",
            "format": "int32"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "user_id": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "UserRole": {
        "type": "string",
        "enum": [
          "Owner",
          "Admin",
          "User"
        ]
      }
    },
    "securitySchemes": {
      "ApiKey": {
        "type": "apiKey",
        "in": "header",
        "name": "Authorization"
      },
      "Cookie": {
        "type": "apiKey",
        "in": "cookie",
        "name": "Authorization"
      }
    }
  },
  "tags": [
    {
      "name": "invitation",
      "description": "Invitation endpoint. Exists to invite users to an organization."
    },
    {
      "name": "auth",
      "description": "Authentication endpoint. Serves to register and authenticate users."
    },
    {
      "name": "user",
      "description": "User endpoint. Enables you to modify user roles and information."
    },
    {
      "name": "organization",
      "description": "Organization endpoint. Enables you to modify organization roles and information."
    },
    {
      "name": "dataset",
      "description": "Dataset endpoint. Datasets belong to organizations and hold configuration information for both client and server. Datasets contain chunks and chunk groups."
    },
    {
      "name": "chunk",
      "description": "Chunk endpoint. Think of chunks as individual searchable units of information. The majority of your integration will likely be with the Chunk endpoint."
    },
    {
      "name": "chunk_group",
      "description": "Chunk groups endpoint. Think of a chunk_group as a bookmark folder within the dataset."
    },
    {
      "name": "file",
      "description": "File endpoint. When files are uploaded, they are stored in S3 and broken up into chunks with text extraction from Apache Tika. You can upload files of pretty much any type up to 1GB in size. See chunking algorithm details at `docs.trieve.ai` for more information on how chunking works. Improved default chunking is on our roadmap."
    },
    {
      "name": "events",
      "description": "Notifications endpoint. Files are uploaded asynchronously and events are sent to the user when the upload is complete. Soon, chunk creation will work in the same way."
    },
    {
      "name": "topic",
      "description": "Topic chat endpoint. Think of topics as the storage system for gen-ai chat memory. Gen AI messages belong to topics."
    },
    {
      "name": "message",
      "description": "Message chat endpoint. Messages are units belonging to a topic in the context of a chat with a LLM. There are system, user, and assistant messages."
    },
    {
      "name": "stripe",
      "description": "Stripe endpoint. Used for the managed SaaS version of this app. Eventually this will become a micro-service. Reach out to the team using contact info found at `docs.trieve.ai` for more information."
    },
    {
      "name": "health",
      "description": "Health check endpoint. Used to check if the server is up and running."
    }
  ]
}